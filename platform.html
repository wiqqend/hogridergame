<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Type-to-Move Platformer</title>
    <style>
        /* --- BASIC PAGE STYLING - jamie --- */
        body {
            background: #000; /* Black background for a retro feel */
            overflow: hidden; /* Prevent scrolling */
            font-family: "Press Start 2P", monospace; /* Pixel-style font */
        }
        canvas {
            display: block;
            margin: 10px auto;
            border: 4px solid #333;
            width: 1200px;
            height: 600px;
        }

        /* --- COMMAND INPUT BOX - jamie --- */
        #commandInput {
            font-size: 16px;
            padding: 10px;
            width: 500px;
            margin: 10px auto;
            border: 3px solid #333;
            border-radius: 8px;
            display: block;
            text-align: center;
        }

        /* --- IN-GAME MENU (COMMAND LIST, LEVEL, ETC.) - jamie --- */
        #menu {
            position: absolute;
            bottom: 10px;
            right: 50px;
            background: rgba(255,255,255,0.9);
            border: 3px solid #333;
            padding: 10px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 5; /* Stays above canvas */
        }

        /* --- BIO POPUP (DEVELOPER BIOS)  - jamie --- */
        #bioPopup {
            position: absolute;
            top: 30px;
            right: 30px;
            width: 300px;
            background: rgba(255,255,255,0.95);
            border: 3px solid #333;
            border-radius: 8px;
            padding: 10px;
            display: none; /* Hidden by default */
            z-index: 10;
            font-size: 12px;
        }
        .bioEntry { margin-bottom: 10px; display: flex; align-items: center; }
        .bioEntry img { width: 50px; height: 50px; border-radius: 6px; margin-right: 10px; }
        #bioClose { display:block; margin-top: 5px; text-align: right; cursor:pointer; color: blue; text-decoration: underline; }

        /* --- START MENU SCREEN - jamie --- */
        #startMenu {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(180deg, #222 0%, #000 100%);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20; /* Highest layer */
        }
        #startMenu img {
            width: 400px;
            margin-bottom: -50px;
            image-rendering: pixelated;
        }
        #startMenu button {
            font-family: "Press Start 2P", monospace;
            font-size: 16px;
            padding: 15px 30px;
            border: 3px solid #ffffff;
            background: transparent;
            color: #fff;
            border-radius: 10px;
            cursor: pointer;
            transition: 0.3s;
            margin: 10px;
        }

        #startMenu button:hover {
            background: #fff;
            color: #000;
        }

        /* --- NEW: DEATH SCREEN STYLING --- */
        #deathScreen {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.8); /* Semi-transparent black */
            color: white;
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 19; /* Just below start menu */
            font-size: 24px;
        }
        #deathScreen h2 {
            color: #FF4444; /* Red color for 'Game Over' */
            font-size: 40px;
        }
        #deathScreen button {
            /* Use same style as start button */
            font-family: "Press Start 2P", monospace;
            font-size: 16px;
            padding: 15px 30px;
            border: 3px solid #ffffff;
            background: transparent;
            color: #fff;
            border-radius: 10px;
            cursor: pointer;
            transition: 0.3s;
            margin-top: 30px;
        }
        #deathScreen button:hover {
            background: #fff;
            color: #000;
        }

    </style>
</head>
<body>
    <div id="startMenu">
        <img src="menu.png" alt="Game Logo">
        <button id="startButton">Start</button>
        <button id="menuButton">made by One Toe</button>
    </div>

    <div id="deathScreen">
        <h2>Game Over!</h2>
        <div>Score: <span id="finalScore">0</span></div>
        <button id="retryButton">Retry</button>
    </div>

    <div id="menu">
        <div><strong>Commands:</strong></div>
        <div>jump | left | right | pause</div>
        <div id="lastCommand"><strong>Last Command:</strong> <span id="cmdDisplay">None</span></div>
    </div>

    <div id="bioPopup">
        <div class="bioEntry">
            <img src="jam.png">
            <div>I'm Jamey this is the best code ever on 67</div>
        </div>
        <div class="bioEntry">
            <img src="jac.png">
            <div>I'm Jacob, yeah thats me, hi.</div>
        </div>
        <div id="bioClose">Close</div>
    </div>

    <canvas id="gameCanvas" width="1200" height="600"></canvas>
    <input id="commandInput" type="text" placeholder="Type a command...">

    <audio id="bgMusic" src="menuaudio.mp3" loop></audio>
    <audio id="runSound" src="run.mp3"></audio>
    <audio id="deadSound" src="dead.mp3"></audio>
    <audio id="jumpSound" src="jump.mp3"></audio>



    <script>
        
        /* --- ELEMENT REFERENCES --- */
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const input = document.getElementById("commandInput");
        const cmdDisplay = document.getElementById("cmdDisplay");
        const bioPopup = document.getElementById("bioPopup");
        const bioClose = document.getElementById("bioClose");
        const startMenu = document.getElementById("startMenu");
        const startButton = document.getElementById("startButton");

        // --- NEW: DEATH SCREEN REFS ---
        const deathScreen = document.getElementById("deathScreen");
        const retryButton = document.getElementById("retryButton");
        const finalScore = document.getElementById("finalScore");

        const music = document.getElementById("bgMusic");
        const runSound = document.getElementById("runSound");
        const deadSound = document.getElementById("deadSound");
        deadSound.volume = 1.0; // full volume
        const jumpSound = document.getElementById("jumpSound");
        jumpSound.volume = 1.0; // good volume balance (1.0 = max)




        /* --- START GAME BUTTON LOGIC GPT CHAT <3 --- */
        startButton.addEventListener("click", () => {
            startMenu.style.display = "none"; // Hide start screen
            music.play().catch(()=>{});       // Play music
            paused = false;                   // Unpause game
            update();                         // Start game loop
        });

        /* --- LOAD IMAGES JACOB/JAMIE--- */
        let playerImg = new Image(); playerImg.src = "hoggif.png";
        let goblinImg = new Image(); goblinImg.src = "goblin.png";
        let coinImg = new Image(); coinImg.src = "head.png";
        let sneakyImg = new Image(); sneakyImg.src = "sneaky.png";
        let sneakyMode = false;
        let sneakyAudio = new Audio("sneakyaudio.mp3");
        sneakyAudio.loop = true;

        /* --- GAME CONSTANTS GPT CHAT <3 --- */
        const tileSize = 50, gravity = 0.6;
        let scrollX = 0, paused = true, totalScore = 0;

        /* --- SKY GRADIENT COLORS JACOB/JAMIE--- */
        let skyTop = {r:135,g:206,b:235}, skyBottom = {r:139,g:195,b:76};
        let targetSkyTop={...skyTop}, targetSkyBottom={...skyBottom};
        const skyFadeSpeed=0.5;

        /* --- FUNCTIONS TO FADE SKY COLORS GPT CHAT <3 --- */
        function randomColorObj(){return{r:Math.random()*256|0,g:Math.random()*256|0,b:Math.random()*256|0};}
        function updateTargetSkyColors(){targetSkyTop=randomColorObj();targetSkyBottom=randomColorObj();}
        setInterval(updateTargetSkyColors,3000);
        function lerp(a,b,t){return a+(b-a)*t;}
        function fadeSky(){
            skyTop.r=lerp(skyTop.r,targetSkyTop.r,skyFadeSpeed);
            skyTop.g=lerp(skyTop.g,targetSkyTop.g,skyFadeSpeed);
            skyTop.b=lerp(skyTop.b,targetSkyTop.b,skyFadeSpeed);
            skyBottom.r=lerp(skyBottom.r,targetSkyBottom.r,skyFadeSpeed);
            skyBottom.g=lerp(skyBottom.g,targetSkyBottom.g,skyFadeSpeed);
            skyBottom.b=lerp(skyBottom.b,targetSkyBottom.b,skyFadeSpeed);
        }
        function rgbStr(c){return`rgb(${c.r|0},${c.g|0},${c.b|0})`;}

        /* --- WORLD GENERATION GPT CHAT <3 --- */
        const worldWidth=1000000, terrain=[1000], greyPlatforms=[], enemies=[100], coins=[];
        let lastHeight=6;

        // Generate terrain columns GPT CHAT <3 
        for(let x=0;x<worldWidth/tileSize;x++){
            let change=Math.floor(Math.random()*3)-1;
            lastHeight=Math.min(Math.max(4,lastHeight+change),8);
            let column=[];
            for(let y=0;y<canvas.height/tileSize;y++){
                if(y<lastHeight)column.push("air");
                else if(y===lastHeight)column.push("grass");
                else if(y>lastHeight&&y<=lastHeight+2)column.push("dirt");
                else column.push("stone");
            }
            terrain.push(column);
        }

        // Add gaps, platforms, and coins GPT CHAT <3 
        for(let x=1;x<terrain.length-50;x++){
            let gapWidth=1;
            while(Math.random()<0.1){gapWidth++;x++;}
            if(gapWidth>=2){
                // Make a gap with lava underneath
                for(let w=0;w<gapWidth;w++){for(let y=0;y<terrain[x+w].length;y++){terrain[x+w][y]="air";}}
                const lavaHeight=Math.floor(canvas.height/tileSize)-2;
                for(let w=0;w<gapWidth;w++){for(let y=lavaHeight;y<terrain[x+w].length;y++){terrain[x+w][y]="lava";}}
                // Add a floating grey platform and coins above it
                let groundY=(terrain[x-1].findIndex(t=>t!=="air")-1)*tileSize;
                greyPlatforms.push({x:(x-1)*tileSize,y:groundY-80,w:gapWidth*tileSize,h:20});
                for(let c=0;c<gapWidth;c++){coins.push({x:(x-1+c)*tileSize+tileSize/2,y:groundY-110,collected:false});}
            }
        }

        /* --- HELPER TO FIND GROUND HEIGHT GPT CHAT <3  --- */
        function findGroundY(xTile){const col=terrain[xTile];for(let y=0;y<col.length;y++){if(col[y]!=="air")return y*tileSize;}return canvas.height-tileSize*3;}

        /* --- SNEAKY CLONE & COMMAND HISTORY VARIABLES --- */
        let commandHistory = [];
        let sneakyClone = null;
        let sneakySpawnTimer = null;
        let sneakyCommandIndex = -1; // Index of the 'sneaky' command in history
        let sneakySpawnX = 0; // --- NEW: To store player's X on command
        let sneakySpawnY = 0; // --- NEW: To store player's Y on command

        /* --- COMMAND HANDLING/CONTROLS Jacob   --- */
        let testMode=false;

            input.addEventListener("keydown", e => {
                if(e.key === "Enter"){
                    const cmd = e.target.value.trim().toLowerCase();
                    e.target.value = "";
                    cmdDisplay.textContent = cmd;

                    // --- Save every command with a timestamp ---
                    commandHistory.push({ command: cmd, timestamp: Date.now() });

                if(cmd.includes("right") || cmd.includes("forward")){
                    player.vx = 6;
                    runSound.currentTime = 0;
                    runSound.play().catch(()=>{});
                }
                if(cmd.includes("left") || cmd.includes("back")){
                    player.vx = -6;
                    runSound.currentTime = 0;
                    runSound.play().catch(()=>{});
                }
                if(cmd.includes("jump") && !player.jumping){
                    player.vy = -12;
                    player.jumping = true;

                    jumpSound.currentTime = 0;
                    jumpSound.play().catch(()=>{});
                }
                if(cmd === "sneaky"){
                    sneakyMode = true;
                    music.pause(); // stop current background music
                    sneakyAudio.currentTime = 0;
                    sneakyAudio.play().catch(()=>{});

                    // --- Start the 5-second spawn timer for the clone ---
                    if (sneakySpawnTimer) clearTimeout(sneakySpawnTimer); // Clear old timer
                    if (sneakyClone) sneakyClone.active = false; // Deactivate old clone
                    
                    // --- NEW: Save the player's EXACT location *now* ---
                    sneakySpawnX = player.x;
                    sneakySpawnY = player.y;

                    sneakyCommandIndex = commandHistory.length - 1; // Get index of this "sneaky" command
                    sneakySpawnTimer = setTimeout(spawnSneakyClone, 5000);
                }
                if(cmd.includes("pause")) paused = !paused;
                if(cmd.includes("unpause")){ if(player.x==50 && player.y==200 && player.score==0) resetPlayer(); paused = false; }
                if(cmd.includes("menu")) paused = true;
                if(cmd.includes("bio")) bioPopup.style.display = "block";
                if(cmd === "testmode"){ testMode = true; cmdDisplay.textContent = "Test mode enabled!"; }
                }
            });

        /* --- NEW: SNEAKY CLONE LOGIC FUNCTIONS --- */
        function spawnSneakyClone() {
            if (paused) return; // Don't spawn if game is paused
            sneakyClone = {
                // --- NEW: Use the saved spawn coordinates ---
                x: sneakySpawnX, 
                y: sneakySpawnY,
                w: player.w, // Same size as player
                h: player.h,
                vx: 0,
                vy: 0, // It spawns with no vertical velocity
                jumping: false, // It spawns on the "ground" (or in mid-air, but not jumping)
                active: true,
                commandToExecuteIndex: sneakyCommandIndex + 1, // Start with command *after* "sneaky"
                nextCommandTimer: null // To hold the setTimeout
            };
            // Start the clone's "brain"
            scheduleSneakyCommand();
        }

        function scheduleSneakyCommand() {
            // Stop if clone is deactivated or game is paused
            if (!sneakyClone || !sneakyClone.active || paused) return;

            let index = sneakyClone.commandToExecuteIndex;

            // Check if the command exists in history yet
            if (index >= commandHistory.length) {
                // Player hasn't entered a new command, so check again in 100ms
                sneakyClone.nextCommandTimer = setTimeout(scheduleSneakyCommand, 100);
                return;
            }

            // Command exists! Calculate the time delay
            let prevTimestamp = commandHistory[index - 1].timestamp;
            let currentTimestamp = commandHistory[index].timestamp;
            let delay = currentTimestamp - prevTimestamp;

            // Schedule this command to run after the calculated delay
            sneakyClone.nextCommandTimer = setTimeout(() => {
                if (!sneakyClone || !sneakyClone.active) return; // Check again if still active

                // Get the command string
                let cmd = commandHistory[index].command;
                
                // Execute the command for the clone
                executeCloneCommand(cmd);

                // Move to the next command index
                sneakyClone.commandToExecuteIndex++;
                
                // Schedule the *next* command lookup
                scheduleSneakyCommand();

            }, delay);
        }

        function executeCloneCommand(cmd) {
            if (!sneakyClone) return;

            // Mimic player commands (without sounds)
            if (cmd.includes("right") || cmd.includes("forward")) {
                sneakyClone.vx = 6;
            }
            if (cmd.includes("left") || cmd.includes("back")) {
                sneakyClone.vx = -6;
            }
            if (cmd.includes("jump") && !sneakyClone.jumping) {
                sneakyClone.vy = -12;
                sneakyClone.jumping = true;
            }
            // Clone ignores other commands like 'pause', 'sneaky', 'bio', etc.
        }

        /* --- ARROW KEY MOVEMENT FOR TESTMODE Jacob --- */
        document.addEventListener("keydown",e=>{
            if(!testMode)return;
            if(e.key==="ArrowRight")player.vx=6;
            if(e.key==="ArrowLeft")player.vx=-6;
            if(e.key==="ArrowUp"&&!player.jumping){player.vy=-12;player.jumping=true;}
        });

        /* --- SPAWN ENEMIES GPT CHAT <3  --- */
        const enemyPositions=[];
        enemyPositions.forEach(xPos=>{
            const xTile=Math.floor(xPos/tileSize);
            const groundY=findGroundY(xTile);
            enemies.push({x:xPos,y:groundY-tileSize*1.2,w:tileSize*1.2,h:tileSize*1.2,vx:0});
        });

        /* --- PLAYER SETUP GPT CHAT <3 --- */
        let player={x:50,y:0,w:tileSize*1.5,h:tileSize*1.5,vx:0,vy:0,score:0,jumping:false,maxDistance:0,touchingWall:false,wallSide:0};

        /* --- DRAW FUNCTIONS GPT CHAT <3 --- */
        function drawTerrain(){for(let x=0;x<terrain.length;x++){for(let y=0;y<terrain[x].length;y++){const b=terrain[x][y];if(b==="air")continue;const px=x*tileSize-scrollX,py=y*tileSize;if(b==="grass")ctx.fillStyle="#4CAF50";else if(b==="dirt")ctx.fillStyle="#8B4513";else if(b==="stone")ctx.fillStyle="#696969";else if(b==="lava"){const g=ctx.createLinearGradient(px,py,px,py+tileSize);g.addColorStop(0,"#FF6600");g.addColorStop(1,"#AA0000");ctx.fillStyle=g;}ctx.fillRect(px,py,tileSize,tileSize);}}}
        function drawGreyPlatforms(){ctx.fillStyle="#888";greyPlatforms.forEach(p=>ctx.fillRect(p.x-scrollX,p.y,p.w,p.h));}
        function drawCoins(){
            coins.forEach(c=>{
                if(!c.collected){
                    const size = 30; // adjust if needed
                    ctx.drawImage(coinImg, c.x - scrollX - size/2, c.y - size/2, size, size);
                }
            });
        }

        function drawEnemies(){enemies.forEach(e=>ctx.drawImage(goblinImg,e.x-scrollX,e.y +50,e.w,e.h));}
        function drawPlayer(){ctx.drawImage(playerImg,player.x-scrollX,player.y,player.w,player.h);}
        
        // --- NEW: Draw function for the clone ---
        function drawSneakyClone(){
            if(sneakyClone && sneakyClone.active) {
                ctx.drawImage(sneakyImg, sneakyClone.x - scrollX, sneakyClone.y, sneakyClone.w, sneakyClone.h);
            }
        }

        /* --- REFACTORED PHYSICS & COLLISION FOR ANY ENTITY --- */
        // This function handles ALL physics and collisions for both
        // the player and the clone, including platforms.
        function handleEntityPhysicsAndCollision(entity) {
            let onGround = false;
            
            // Physics
            entity.vy += gravity;
            entity.y += entity.vy;
            entity.x += entity.vx;
            entity.vx *= 0.9;

            // Collision handling
            const bounceFactor = 0.4;
            const entityLeft = entity.x, entityRight = entity.x + entity.w, entityTop = entity.y, entityBottom = entity.y + entity.h;
            const tileStartX = Math.floor(entityLeft / tileSize), tileEndX = Math.floor(entityRight / tileSize);
            const tileStartY = Math.floor(entityTop / tileSize), tileEndY = Math.floor(entityBottom / tileSize);

            // Tile collisions
            for (let tx = tileStartX; tx <= tileEndX; tx++) {
                for (let ty = tileStartY; ty <= tileEndY; ty++) {
                    const tile = (terrain[tx] || [])[ty];
                    if (!tile || tile === "air" || tile === "lava") continue;
                    const tileX = tx * tileSize, tileY = ty * tileSize;
                    const overlapX = Math.min(entityRight - tileX, tileX + tileSize - entityLeft);
                    const overlapY = Math.min(entityBottom - tileY, tileY + tileSize - entityTop);
                    if (overlapY < overlapX) {
                        // Vertical collision
                        if (entity.vy > 0 && entityBottom - entity.vy <= tileY) {
                            entity.y = tileY - entity.h; entity.vy = -Math.abs(entity.vy) * bounceFactor;
                            if (Math.abs(entity.vy) < 2) { entity.vy = 0; onGround = true; entity.jumping = false; }
                        } else if (entity.vy < 0 && entityTop - entity.vy >= tileY + tileSize) {
                            entity.y = tileY + tileSize; entity.vy = Math.abs(entity.vy) * bounceFactor;
                        }
                    } else {
                        // Horizontal collision
                        if (entityRight - entity.vx <= tileX) { entity.x = tileX - entity.w; entity.vx = -Math.abs(entity.vx) * bounceFactor; }
                        else if (entityLeft - entity.vx >= tileX + tileSize) { entity.x = tileX + tileSize; entity.vx = Math.abs(entity.vx) * bounceFactor; }
                    }
                }
            }

            // Platform collision (This is the logic you asked for)
            greyPlatforms.forEach(p => {
                if (entity.x + entity.w > p.x && entity.x < p.x + p.w && entity.y + entity.h > p.y && entity.y + entity.h < p.y + p.h + 10 && entity.vy >= 0) {
                    entity.y = p.y - entity.h; entity.vy = 0; entity.jumping = false; onGround = true;
                }
            });

            // This was used by the player, but we'll return it just in case
            // (though the clone doesn't use it)
            return onGround;
        }


        /* --- PLAYER RESET & DEATH GPT CHAT <3 --- */
        function resetPlayer(){
            player.x=50;player.y=200;player.vx=0;player.vy=0;player.jumping=false;
            
            // --- NEW: Reset sneaky clone and history ---
            if (sneakySpawnTimer) clearTimeout(sneakySpawnTimer);
            if (sneakyClone && sneakyClone.nextCommandTimer) clearTimeout(sneakyClone.nextCommandTimer);
            sneakySpawnTimer = null;
            sneakyClone = null;
            sneakyCommandIndex = -1;
            commandHistory = [];
            sneakySpawnX = 0; // --- NEW: Reset spawn location
            sneakySpawnY = 0; // --- NEW: Reset spawn location

            // --- NEW: Reset sneaky mode state ---
            sneakyMode = false;
            sneakyAudio.pause();
            sneakyAudio.currentTime = 0;
        }

        function death(){
            // --- NEW: Clear any sneaky timers/clones on death ---
            if (sneakySpawnTimer) clearTimeout(sneakySpawnTimer);
            if (sneakyClone && sneakyClone.nextCommandTimer) clearTimeout(sneakyClone.nextCommandTimer);
            sneakySpawnTimer = null;
            sneakyClone = null; // Make it disappear immediately

            paused = true;

            // --- NEW: Stop all sounds ---
            runSound.pause();
            runSound.currentTime = 0;
            music.pause();
            sneakyAudio.pause();

            deadSound.currentTime = 0;
            deadSound.volume = 1.0;
            deadSound.play().catch(()=>{});

            // --- NEW: Show death screen ---
            finalScore.textContent = Math.floor(player.score);
            deathScreen.style.display = "flex";

            // --- REMOVED OLD TIMEOUT ---
            /*
            setTimeout(() => {
                // We must use a custom modal/message box instead of alert()
                // For now, I will just log to console and reset
                console.log("💀 Game Over! Score: " + Math.floor(player.score));
                // In a real game, you would show a death screen here
                // alert("💀 Game Over! Score: " + Math.floor(player.score));
                resetPlayer();
                totalScore = 0;
                // --- NEW: History is cleared inside resetPlayer() ---
            }, 500); // waits half a second for the sound
            */
        }

        /* --- MAIN UPDATE LOOP GPT CHAT <3 --- */
            function update(){
                if(paused){requestAnimationFrame(update);return;}

                // --- REMOVED OLD SNEAKYMODE DRAW LOGIC ---

                // Background sky fade (THIS IS DUPLICATED IN ORIGINAL - keeping it)
                fadeSky();
                const grad=ctx.createLinearGradient(0,0,0,canvas.height);
                grad.addColorStop(0,rgbStr(skyTop));
                grad.addColorStop(1,rgbStr(skyBottom));
                ctx.fillStyle=grad;
                ctx.fillRect(0,0,canvas.width,canvas.height);

                // --- NEW: Draw sneaky background with opacity ---
                if (sneakyMode) {
                    ctx.globalAlpha = 0.8; // 80% opacity ("high opacity")
                    ctx.drawImage(sneakyImg, 0, 0, canvas.width, canvas.height);
                    ctx.globalAlpha = 1.0; // Reset alpha for all other drawing
                }

                // --- NEW: Use the refactored physics function for BOTH entities ---
                handleEntityPhysicsAndCollision(player);
                if (sneakyClone && sneakyClone.active) {
                    handleEntityPhysicsAndCollision(sneakyClone);
                }

                // Coin collection GPT CHAT <3 
                coins.forEach(c=>{
                    if(!c.collected&&player.x+player.w>c.x-10&&player.x<c.x+10&&player.y+player.h>c.y-10&&player.y<c.y+10){
                        c.collected=true;player.score+=5;totalScore+=5;
                    }
                });

                // Lava death Jacob/Jamie
                const playerTileX=Math.floor((player.x+player.w/2)/tileSize);
                const playerTileY=Math.floor((player.y+player.h)/tileSize);
                if(terrain[playerTileX]&&terrain[playerTileX][playerTileY]==="lava"){death();}

                // Enemy collision 
                enemies.forEach(e=>{
                    if(player.x<e.x+e.w&&player.x+player.w>e.x&&player.y<e.y+e.h&&player.y+player.h>e.y){death();}
                });

                // --- NEW: Sneaky Clone collision & status checks ---
                if (sneakyClone && sneakyClone.active) {
                    // 1. Check for collision with player
                    if (player.x < sneakyClone.x + sneakyClone.w &&
                        player.x + player.w > sneakyClone.x &&
                        player.y < sneakyClone.y + sneakyClone.h &&
                        player.y + player.h > sneakyClone.y) {
                        death(); // Player dies
                    }
                    
                    // 2. Check if clone hits lava or falls off screen
                    const cloneTileX = Math.floor((sneakyClone.x + sneakyClone.w / 2) / tileSize);
                    const cloneTileY = Math.floor((sneakyClone.y + sneakyClone.h) / tileSize);
                    if ((terrain[cloneTileX] && terrain[cloneTileX][cloneTileY] === "lava") || sneakyClone.y > canvas.height) {
                        sneakyClone.active = false; // Deactivate clone
                        if (sneakyClone.nextCommandTimer) clearTimeout(sneakyClone.nextCommandTimer);
                    }
                }

                // Fall off screen death jacob/jamie
                if(player.y>canvas.height){death();}

                // Scrolling camera gpt chat
                scrollX=Math.max(0,player.x-canvas.width/2);

                // Draw everything jacob
                drawTerrain();
                drawGreyPlatforms();
                drawCoins();
                drawEnemies();
                drawPlayer();
                drawSneakyClone(); // --- NEW: Draw the clone ---

                // Score HUD gptchat
                ctx.fillStyle="#000";ctx.font="20px monospace";
                ctx.fillText("Score: "+Math.floor(player.score),10,30);
                ctx.fillText("Total: "+totalScore,10,55);

                requestAnimationFrame(update);
            }

        /* --- CLOSE BIO POPUP gptchat--- */ 
        bioClose.addEventListener("click",()=>bioPopup.style.display="none");


        /* --- NEW: RETRY BUTTON LOGIC --- */
        retryButton.addEventListener("click", () => {
            deathScreen.style.display = "none"; // Hide death screen
            totalScore = 0;
            player.score = 0; // Reset player's score
            resetPlayer();    // Reset player position, sneaky state, etc.
            music.play().catch(()=>{}); // Restart the main music
            paused = false;   // Unpause the game
        });


    </script>
</body>
</html>
